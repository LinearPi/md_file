# 构建图

## 内容

### [构建图](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#AUTOGENERATED-building-graphs)

- 核心图数据结构
  - [`class tf.Graph`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Graph)
  - [`class tf.Operation`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Operation)
  - [`class tf.Tensor`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Tensor)
- 张量类型
  - [`class tf.DType`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#DType)
  - [`tf.as_dtype(type_value)`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#as_dtype)
- 实用功能
  - [`tf.device(dev)`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#device)
  - [`tf.name_scope(name)`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#name_scope)
  - [`tf.control_dependencies(control_inputs)`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#control_dependencies)
  - [`tf.convert_to_tensor(value, dtype=None, name=None)`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#convert_to_tensor)
  - [`tf.get_default_graph()`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#get_default_graph)
  - [`tf.import_graph_def(graph_def, input_map=None, return_elements=None, name=None, op_dict=None)`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#import_graph_def)
- 图集
  - [`tf.add_to_collection(name, value)`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#add_to_collection)
  - [`tf.get_collection(key, scope=None)`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#get_collection)
  - [`class tf.GraphKeys`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#GraphKeys)
- 定义新业务
  - [`class tf.RegisterGradient`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#RegisterGradient)
  - [`tf.NoGradient(op_type)`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#NoGradient)
  - [`class tf.RegisterShape`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#RegisterShape)
  - [`class tf.TensorShape`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#TensorShape)
  - [`class tf.Dimension`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Dimension)
  - [`tf.op_scope(values, name, default_name)`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#op_scope)
  - [`tf.get_seed(op_seed)`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#get_seed)

用于构建TensorFlow图的类和函数。

## 核心图数据结构

------

### `class tf.Graph`

TensorFlow计算，表示为数据流图。

A `Graph`包含一组 [`Operation`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Operation)对象，表示计算单位; 和 [`Tensor`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Tensor)对象，表示在操作之间流动的数据单位。

`Graph`始终注册默认值，并可通过调用访问 [`tf.get_default_graph()`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#get_default_graph)。要将操作添加到默认图形，只需调用定义新的函数之一`Operation`：

```
c = tf.constant(4.0)
assert c.graph is tf.get_default_graph()
```

另一个典型用法涉及 [`Graph.as_default()`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Graph.as_default) 上下文管理器，它会覆盖上下文生命周期的当前默认图：

```
g = tf.Graph()
with g.as_default():
  # Define operations and tensors in `g`.
  c = tf.constant(30.0)
  assert c.graph is g
```

重要说明：此类对于图构建*不是*线程安全的。应从单个线程创建所有操作，或者必须提供外部同步。除非另有说明，否则所有方法都不是线程安全的。

------

#### `tf.Graph.__init__()`

创建一个新的空图。

------

#### `tf.Graph.as_default()`

返回一个上下文管理器，使其`Graph`成为默认图形。

如果要在同一进程中创建多个图形，则应使用此方法。为方便起见，我们提供了一个全局默认图表，如果您没有明确创建新图表，则所有操作都将添加到此图表中。使用此方法`with`关键字指定应在块的范围内创建的操作应添加到此图中。

默认图是当前线程的属性。如果您创建一个新线程，并希望在该线程中使用默认图形，则必须`with g.as_default():`在该线程的函数中显式添加。

以下代码示例是等效的：

```
# 1. Using Graph.as_default():
g = tf.Graph()
with g.as_default():
  c = tf.constant(5.0)
  assert c.graph is g

# 2. Constructing and making default:
with tf.Graph().as_default() as g:
  c = tf.constant(5.0)
  assert c.graph is g
```

##### 返回：

用于将此图形用作默认图形的上下文管理器。

------

#### `tf.Graph.as_graph_def(from_version=None)`

返回`GraphDef`此图的序列化表示。

序列化`GraphDef`可以导入到另一个`Graph` （使用[`import_graph_def()`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#import_graph_def)）或与 [C ++会话API一起使用](http://www.tensorfly.cn/tfdoc/api_docs/cc/index.html)。

此方法是线程安全的。

##### ARGS：

- **from_version**： 可选的。如果设置了此选项，则返回`GraphDef` 仅包含已添加到此图形的节点的a，因为其`version`属性具有给定值。

##### 返回：

甲[`GraphDef`](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/graph.proto) 协议缓冲器。

------

#### `tf.Graph.finalize()`

最终确定此图表，使其成为只读。

通话后`g.finalize()`，无法添加任何新操作 `g`。此方法用于确保在多个线程之间共享时不向图表添加任何操作，例如使用a时[`QueueRunner`](http://www.tensorfly.cn/tfdoc/api_docs/python/train.html#QueueRunner)。

------

#### `tf.Graph.finalized`

如果此图已完成，则为True。

------

#### `tf.Graph.control_dependencies(control_inputs)`

返回指定控件依赖关系的上下文管理器。

与`with`关键字一起使用以指定在上下文中构造的所有操作都应具有控制依赖性 `control_inputs`。例如：

```
with g.control_dependencies([a, b, c]):
  # `d` and `e` will only run after `a`, `b`, and `c` have executed.
  d = ...
  e = ...
```

`control_dependencies()`可以嵌套多个调用，在这种情况下，new `Operation`将对`control_inputs`所有活动上下文的并集具有控制依赖性。

```
with g.control_dependencies([a, b]):
  # Ops declared here run after `a` and `b`.
  with g.control_dependencies([c, d]):
    # Ops declared here run after `a`, `b`, `c`, and `d`.
```

*NB*的控制依赖上下文应用于*只*到被上下文中构建OPS。仅在上下文中使用op或tensor不会添加控件依赖项。以下示例说明了这一点：

```
# WRONG
def my_func(pred, tensor):
  t = tf.matmul(tensor, tensor)
  with tf.control_dependencies([pred]):
    # The matmul op is created outside the context, so no control
    # dependency will be added.
    return t

# RIGHT
def my_func(pred, tensor):
  with tf.control_dependencies([pred]):
    # The matmul op is created in the context, so a control dependency
    # will be added.
    return tf.matmul(tensor, tensor)
```

##### ARGS：

- **control_inputs**：在运行上下文中定义的操作之前必须执行或计算的一个`Operation`或多个`Tensor`对象的列表。

##### 返回：

一个上下文管理器，它指定在上下文中构造的所有操作的控制依赖性。

##### 举：

- **TypeError**：如果`control_inputs`不是列表`Operation`或 `Tensor`对象。

------

#### `tf.Graph.device(device_name_or_function)`

返回一个上下文管理器，指定要使用的默认设备。

该`device_name_or_function`参数可以是一个设备的名称字符串，设备功能，或无：

- 如果它是设备名称字符串，则在此上下文中构造的所有操作都将分配给具有该名称的设备。
- 如果它是一个函数，它将被视为从操作对象到设备名称字符串的函数，并在每次创建新操作时调用。操作将以返回的名称分配给设备。
- 如果为None，则清除默认设备。

例如：

```
with g.device('/gpu:0'):
  # All operations constructed in this context will be placed
  # on GPU 0.
  with g.device(None):
    # All operations constructed in this context will have no
    # assigned device.

# Defines a function from `Operation` to device string.
def matmul_on_gpu(n):
  if n.type == "MatMul":
    return "/gpu:0"
  else:
    return "/cpu:0"

with g.device(matmul_on_gpu):
  # All operations of type "MatMul" constructed in this context
  # will be placed on GPU 0; all other operations will be placed
  # on CPU 0.
```

##### ARGS：

- **device_name_or_function**：在上下文中使用的设备名称或函数。

##### 返回：

上下文管理器，指定用于新创建的操作的默认设备。

------

#### `tf.Graph.name_scope(name)`

返回为操作创建层次名称的上下文管理器。

图形维护一组名称范围。一个`with name_scope(...):` 语句将一个新名称压入堆栈的上下文的生命期。

该`name`论点将解释如下：

- 字符串（不以'/'结尾）将创建一个新的名称范围，其中 `name`将附加到上下文中创建的所有操作的前缀。如果`name`以前使用过，它将通过调用变得独一无二`self.unique_name(name)`。
- 先前从`with g.name_scope(...) as scope:`语句捕获的作用域将被视为“绝对”名称作用域，这使得可以重新输入现有作用域。
- 值`None`或空字符串将当前名称范围重置为顶级（空）名称范围。

例如：

```
with tf.Graph().as_default() as g:
  c = tf.constant(5.0, name="c")
  assert c_1.name == "c"
  c_1 = tf.constant(6.0, name="c")
  assert c_1.name == "c_1"

  # Creates a scope called "nested"
  with g.name_scope("nested") as scope:
    nested_c = tf.constant(10.0, name="c")
    assert nested_c.name == "nested/c"

    # Creates a nested scope called "inner".
    with g.name_scope("inner"):
      nested_inner_c = tf.constant(20.0, name="c")
      assert nested_inner_c.name == "nested/inner/c"

    # Create a nested scope called "inner_1".
    with g.name_scope("inner"):
      nested_inner_1_c = tf.constant(30.0, name="c")
      assert nested_inner_1_c.name == "nested/inner_1/c"

      # Treats `scope` as an absolute name scope, and
      # switches to the "nested/" scope.
      with g.name_scope(scope):
        nested_d = tf.constant(40.0, name="d")
        assert nested_d.name == "nested/d"

        with g.name_scope(""):
          e = tf.constant(50.0, name="e")
          assert e.name == "e"
```

可以捕获作用域本身的名称，该名称将作用域`with g.name_scope(...) as scope:`的名称存储在变量中`scope`。此值可用于命名表示在作用域中执行ops的总体结果的操作。例如：

```
inputs = tf.constant(...)
with g.name_scope('my_layer') as scope:
  weights = tf.Variable(..., name="weights")
  biases = tf.Variable(..., name="biases")
  affine = tf.matmul(inputs, weights) + biases
  output = tf.nn.relu(affine, name=scope)
```

##### ARGS：

- **name**：范围的名称。

##### 返回：

`name`作为新名称范围 安装的上下文管理器。

一个`Graph`实例支持由名称标识的“集合”任意数量。为了方便构建大型图形，集合可以存储相关对象组：例如，对构建图形期间创建的所有变量`tf.Variable`使用集合（命名 [`tf.GraphKeys.VARIABLES`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#GraphKeys)）。调用者可以通过指定新名称来定义其他集合。

------

#### `tf.Graph.add_to_collection(name, value)`

`value`具有给定的集合中的商店`name`。

##### ARGS：

- **name**：收集的关键。例如，`GraphKeys`该类包含许多集合的标准名称。
- **value**：要添加到集合的值。

------

#### `tf.Graph.get_collection(name, scope=None)`

返回具有给定的集合中的值列表`name`。

##### ARGS：

- **key**：收集的关键。例如，`GraphKeys`该类包含许多集合的标准名称。
- **scope**:(可选。）如果提供，则过滤结果列表以仅包括名称以此字符串开头的项目。

##### 返回：

具有给定的集合中的值`name`列表，如果没有向该集合添加任何值，则为空列表。该列表包含按收集顺序排列的值。

------

#### `tf.Graph.as_graph_element(obj, allow_tensor=True, allow_operation=True)`

返回`obj`作为`Operation`或引用的对象`Tensor`。

此函数验证`obj`表示此图的元素，如果不是，则提供信息性错误消息。

此函数是从Session API中的外部参数引用获取/验证其中一个允许类型的对象的规范方法。

可以从多个线程同时调用此方法。

##### ARGS：

- **obj**：A `Tensor`，an `Operation`，或张量或操作的名称。也可以是具有`_as_graph_element()`返回其中一种类型的值的方法的任何对象。
- **allow_tensor**：如果是，`obj`可以参考a `Tensor`。
- **allow_operation**：如果是，`obj`可以参考一个`Operation`。

##### 返回：

图中的`Tensor`或`Operation`对应于`obj`。

##### 举：

- **TypeError**：如果`obj`不是我们支持尝试转换为类型的类型。
- **ValueError**：如果`obj`是合适的类型但无效。例如，无效的字符串。
- **KeyError**：如果`obj`不是图表中的对象。

------

#### `tf.Graph.get_operation_by_name(name)`

返回`Operation`给定的`name`。

可以从多个线程同时调用此方法。

##### ARGS：

- **name**：`Operation`要返回的名称。

##### 返回：

在`Operation`给定`name`。

##### 举：

- **TypeError**：如果`name`不是字符串。
- **KeyError**：如果`name`不对应于此图中的操作。

------

#### `tf.Graph.get_tensor_by_name(name)`

返回`Tensor`给定的`name`。

可以从多个线程同时调用此方法。

##### ARGS：

- **name**：`Tensor`要返回的名称。

##### 返回：

在`Tensor`给定`name`。

##### 举：

- **TypeError**：如果`name`不是字符串。
- **KeyError**：如果`name`不对应于此图中的张量。

------

#### `tf.Graph.get_operations()`

返回图表中的操作列表。

您可以就地修改操作，但是对列表的修改（例如插入/删除）对图表已知的操作列表没有影响。

可以从多个线程同时调用此方法。

##### 返回：

操作列表。

------

#### `tf.Graph.get_default_device()`

返回默认设备。

##### 返回：

一个字符串。

------

#### `tf.Graph.seed`

------

#### `tf.Graph.unique_name(name)`

返回“name”的唯一操作名称。

注意：您很少需要直接调用unique_name（）。大多数情况下，您只需要创建“with g.name_scope（）”块来生成结构化名称。

`unique_name`用于生成结构名称，以“/”分隔，以帮助在调试图形时识别操作。操作名称显示在TensorFlow运行时报告的错误消息中，以及各种可视化工具（如TensorBoard）中。

##### ARGS：

- **name**：一个名字`Operation`。

##### 返回：

要传递给`create_op()`它的字符串将用于命名正在创建的操作。

------

#### `tf.Graph.version`

返回随操作添加到图形时增加的版本号。

------

#### `tf.Graph.create_op(op_type, inputs, dtypes, input_types=None, name=None, attrs=None, op_def=None, compute_shapes=True)`

`Operation`在此图中创建一个。

这是一个用于创建的低级接口`Operation`。大多数程序不会直接调用此方法，而是使用Python op构造函数，例如`tf.constant()`，将ops添加到默认图形中。

##### ARGS：

- **op_type**：`Operation`要创建的类型。这对应于`OpDef.name`定义操作的proto 的 字段。
- **inputs**：`Tensor`将输入到的对象列表`Operation`。
- **dtypes**：`DType`对象列表，它将是操作生成的张量类型。
- **input_types**:(可选。）`DType`s 列表，它将是操作使用的张量类型。默认情况下，使用`DType`每个输入的基数 `inputs`。期望引用类型输入的操作必须`input_types`明确指定。
- **name**:(可选。）操作的字符串名称。如果未指定，则基于生成名称`op_type`。
- **attrs**：（可选）的列表`AttrValue`PROTOS的`attr`所述的场`NodeDef`，将表示该操作的原。
- **op_def**:(可选。）`OpDef`描述`op_type`操作将具有的proto 。
- **compute_shapes**:(可选。）如果为True，将执行形状推断以计算输出的形状。

##### 举：

- **TypeError**：如果任何输入不是a `Tensor`。

##### 返回：

一个`Operation`对象。

------

#### `tf.Graph.gradient_override_map(op_type_map)`

实验：用于覆盖梯度函数的上下文管理器。

此上下文管理器可用于覆盖将在上下文范围内用于ops的渐变函数。

例如：

```
@tf.RegisterGradient("CustomSquare")
def _custom_square_grad(op, inputs):
  # ...

with tf.Graph().as_default() as g:
  c = tf.constant(5.0)
  s_1 = tf.square(c)  # Uses the default gradient for tf.square.
  with g.gradient_override_map({"Square": "CustomSquare"}):
    s_2 = tf.square(s_2)  # Uses _custom_square_grad to compute the
                          # gradient of s_2.
```

##### ARGS：

- **op_type_map**：将op类型字符串映射到备用op类型字符串的字典。

##### 返回：

上下文管理器，用于设置用于在该上下文中创建的一个或多个操作的备用操作类型。

##### 举：

- **TypeError**：如果`op_type_map`不是将字符串映射到字符串的字典。

------

### `class tf.Operation`

表示在张量上执行计算的图形节点。

An `Operation`是TensorFlow `Graph`中的一个节点，它将零个或多个`Tensor`对象作为输入，并生成零个或多个`Tensor` 对象作为输出。类型的对象`Operation`是通过调用Python操作构造函数（例如[`tf.matmul()`](http://www.tensorfly.cn/tfdoc/api_docs/python/math_ops.html#matmul)）或创建的[`Graph.create_op()`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Graph.create_op)。

例如，`c = tf.matmul(a, b)`创建一个`Operation`“MatMul”类型，它接受张量`a`和`b`输入，并产生`c` 输出。

在会话中启动图形后，`Operation`可以通过将其传递给执行来执行 [`Session.run()`](http://www.tensorfly.cn/tfdoc/api_docs/python/client.html#Session.run)。 `op.run()`是一个呼叫的快捷方式`tf.get_default_session().run(op)`。

------

#### `tf.Operation.name`

此操作的全名。

------

#### `tf.Operation.type`

op的类型（例如`"MatMul"`）。

------

#### `tf.Operation.inputs`

`Tensor`表示此操作的数据输入的对象列表。

------

#### `tf.Operation.control_inputs`

在`Operation`其上由此op具有控制依赖对象。

在执行此操作之前，TensorFlow将确保操作`self.control_inputs`已完成执行。出于性能原因，此机制可用于顺序运行操作，或确保以正确的顺序观察操作的副作用。

##### 返回：

`Operation`对象 列表。

------

#### `tf.Operation.outputs`

`Tensor`表示此操作的输出的对象列表。

------

#### `tf.Operation.device`

已分配此操作的设备的名称（如果有）。

##### 返回：

已分配此op的设备的字符串名称，如果尚未分配给设备，则为None。

------

#### `tf.Operation.graph`

`Graph`包含此操作的那个。

------

#### `tf.Operation.run(feed_dict=None, session=None)`

在a中运行此操作`Session`。

调用此方法将执行生成此操作所需输入的所有先前操作。

*NB*在调用之前`Operation.run()`，其图形必须已在会话中启动，并且默认会话必须可用，或者`session`必须明确指定。

##### ARGS：

- **feed_dict**：将`Tensor`对象映射到Feed值的字典。有关[`Session.run()`](http://www.tensorfly.cn/tfdoc/api_docs/python/client.html#Session.run) 有效Feed值的说明，请参阅参考资料。
- **session**:(可选。）`Session`用于运行此操作。如果不是，则使用默认会话。

------

#### `tf.Operation.get_attr(name)`

返回给定的此op的attr的值`name`。

##### ARGS：

- **name**：要获取的attr的名称。

##### 返回：

attr的值，作为Python对象。

##### 举：

- **ValueError**：如果此op没有给定的attr `name`。

------

#### `tf.Operation.traceback`

从构造此操作时返回调用堆栈。

#### 其他方法

------

#### `tf.Operation.__init__(node_def, g, inputs=None, output_types=None, control_inputs=None, input_types=None, original_op=None, op_def=None)`

创造一个`Operation`。

注意：此构造函数验证Operation的名称（传递为“node_def.name”）。有效的操作名称与以下正则表达式匹配：

[A-ZA-Z0-9] [A-ZA-Z0-9 _.- /] *

##### ARGS：

- **node_def**：graph_pb2.NodeDef。NodeDef用于操作。用于graph_pb2.NodeDef的属性，通常为“name”，“op”和“device”。“输入”属性在此处无关紧要，因为它将在生成模型时计算。
- **g**：图表。父图。
- **inputs**：Tensor对象列表。此操作的输入。
- **output_types**：types_pb2.DataType列表。通过此操作计算的张量类型列表。此列表的长度表示操作的输出端点数。
- **control_inputs**：具有控制依赖关系的操作或张量列表。
- **input_types**：types_pb2.DataType列表，表示操作接受的张量类型。默认情况下，在输入中使用[x.dtype.base_dtype表示x]。期望引用类型输入的操作必须明确指定这些操作。
- **original_op**： 可选的。用于将新操作与现有操作相关联（例如，具有已复制操作的副本）。
- **op_def**： 可选的。op_def_pb2.OpDef proto，描述此Operation表示的op类型。

##### 举：

- **TypeError**：如果控件输入不是Operations或Tensors，或者node_def不是NodeDef，或者g不是Graph，或者输入不是Tensors，或者input和input_types不兼容。
- **ValueError**：如果node_def名称无效。

------

#### `tf.Operation.node_def`

返回`NodeDef`此操作的序列化表示形式。

##### 返回：

甲 [`NodeDef`](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/graph.proto) 协议缓冲器。

------

#### `tf.Operation.op_def`

返回`OpDef`表示此op类型的proto。

##### 返回：

一个 [`OpDef`](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/op_def.proto) 协议缓冲器。

------

#### `tf.Operation.values()`

弃用：使用输出。

------

### `class tf.Tensor`

表示由a生成的值`Operation`。

A `Tensor`是一个输出的符号句柄 `Operation`。它不保存该操作的输出值，而是提供在TensorFlow中计算这些值的方法[`Session`](http://www.tensorfly.cn/tfdoc/api_docs/python/client.html#Session)。

这个课有两个主要目的：

1. A `Tensor`可以作为输入传递给另一个`Operation`。这将在操作之间建立数据流连接，使TensorFlow能够执行`Graph`表示大型多步计算的整体。
2. 在会话中启动图形后，`Tensor`可以通过将其传递给计算值 来计算 [`Session.run()`](http://www.tensorfly.cn/tfdoc/api_docs/python/client.html#Session.run)。 `t.eval()`是一个呼叫的快捷方式 `tf.get_default_session().run(t)`。

在以下示例中，`c`，`d`，和`e`是象征性`Tensor` 的目的，而`result`是存储一个具体值的numpy的数组：

```
# Build a dataflow graph.
c = tf.constant([[1.0, 2.0], [3.0, 4.0]])
d = tf.constant([[1.0, 1.0], [0.0, 1.0]])
e = tf.matmul(c, d)

# Construct a `Session` to execut the graph.
sess = tf.Session()

# Execute the graph and store the value that `e` represents in `result`.
result = sess.run(e)
```

------

#### `tf.Tensor.dtype`

在`DType`这个张量元素。

------

#### `tf.Tensor.name`

此张量的字符串名称。

------

#### `tf.Tensor.value_index`

该张量的指数在其输出中`Operation`。

------

#### `tf.Tensor.graph`

`Graph`包含这个张量的那个。

------

#### `tf.Tensor.op`

的`Operation`产生，这个张量作为输出。

------

#### `tf.Tensor.consumers()`

返回`Operation`消耗此张量的s 列表。

##### 返回：

`Operation`s 的列表。

------

#### `tf.Tensor.eval(feed_dict=None, session=None)`

在a中评估这个张量`Session`。

调用此方法将执行所有先前的操作，这些操作将生成生成此张量的操作所需的输入。

*NB*在调用之前`Tensor.eval()`，其图形必须已在会话中启动，并且默认会话必须可用，或者`session`必须明确指定。

##### ARGS：

- **feed_dict**：将`Tensor`对象映射到Feed值的字典。有关[`Session.run()`](http://www.tensorfly.cn/tfdoc/api_docs/python/client.html#Session.run)有效Feed值的说明，请参阅参考资料。
- **session**:(可选。）`Session`用于评估此张量。如果不是，则使用默认会话。

##### 返回：

对应于此张量值的numpy数组。

------

#### `tf.Tensor.get_shape()`

返回`TensorShape`表示此张量的形状。

使用为每种`Operation`类型注册的形状推断函数计算形状`tf.RegisterShape`。有关[`TensorShape`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#TensorShape)形状代表的更多详细信息，请参阅。

推断的张量形状用于提供形状信息，而不必在会话中启动图形。这可用于调试和提供早期错误消息。例如：

```
c = tf.constant([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])

print c.get_shape()
==> TensorShape([Dimension(2), Dimension(3)])

d = tf.constant([[1.0, 0.0], [0.0, 1.0], [1.0, 0.0], [0.0, 1.0]])

print d.get_shape()
==> TensorShape([Dimension(4), Dimension(2)])

# Raises a ValueError, because `c` and `d` do not have compatible
# inner dimensions.
e = tf.matmul(c, d)

f = tf.matmul(c, d, transpose_a=True, transpose_b=True)

print f.get_shape()
==> TensorShape([Dimension(3), Dimension(4)])
```

在某些情况下，推断的形状可能具有未知的尺寸。如果调用者具有关于这些维度的值的附加信息，`Tensor.set_shape()`则可以用于增加推断的形状。

##### 返回：

A `TensorShape`表示该张量的形状。

------

#### `tf.Tensor.set_shape(shape)`

更新此张量的形状。

可以多次调用此方法，并将给定`shape`的此张量的当前形状合并 。它可用于提供有关此张量形状的其他信息，这些信息无法仅从图表中推断出来。例如，这可用于提供有关图像形状的其他信息：

```
_, image_data = tf.TFRecordReader(...).read(...)
image = tf.image.decode_png(image_data, channels=3)

# The height and width dimensions of `image` are data dependent, and
# cannot be computed without executing the op.
print image.get_shape()
==> TensorShape([Dimension(None), Dimension(None), Dimension(3)])

# We know that each image in this dataset is 28 x 28 pixels.
image.set_shape([28, 28, 3])
print image.get_shape()
==> TensorShape([Dimension(28), Dimension(28), Dimension(3)])
```

##### ARGS：

- **shape**：A `TensorShape`代表这个张量的形状。

##### 举：

- **ValueError**：如果`shape`与此张量的当前形状不兼容。

#### 其他方法

------

#### `tf.Tensor.__init__(op, value_index, dtype)`

创建一个新的`Tensor`。

##### ARGS：

- **op**：安`Operation`。`Operation`计算这个张量。
- **value_index**：安`int`。生成此张量的操作终点的索引。
- **dtype**：A `types.DType`。存储在此张量中的数据类型。

##### 举：

- **TypeError**：如果op不是`Operation`。

------

#### `tf.Tensor.device`

将生成此张量的设备的名称，或无。

## 张量类型

------

### `class tf.DType`

表示a中元素的类型`Tensor`。

`DType`定义了以下对象：

- `tf.float32`：32位单精度浮点数。
- `tf.float64`：64位双精度浮点数。
- `tf.bfloat16`：16位截断浮点。
- `tf.complex64`：64位单精度复合体。
- `tf.int8`：8位有符号整数。
- `tf.uint8`：8位无符号整数。
- `tf.int32`：32位有符号整数。
- `tf.int64`：64位有符号整数。
- `tf.bool`：布尔值。
- `tf.string`：字符串。
- `tf.qint8`：量化的8位有符号整数。
- `tf.quint8`：量化的8位无符号整数。
- `tf.qint32`：量化的32位有符号整数。

此外，具有`_ref`后缀的这些类型的变体被定义用于参考类型的张量。

该`tf.as_dtype()`函数将numpy类型和字符串类型名称转换为`DType`对象。

------

#### `tf.DType.is_compatible_with(other)`

如果`other`DType将转换为此DType，则返回True 。

转换规则如下：

```
DType(T)       .is_compatible_with(DType(T))        == True
DType(T)       .is_compatible_with(DType(T).as_ref) == True
DType(T).as_ref.is_compatible_with(DType(T))        == False
DType(T).as_ref.is_compatible_with(DType(T).as_ref) == True
```

##### ARGS：

- **other**：A `DType`（或可以转换为a的对象`DType`）。

##### 返回：

如果`other` `DType`遗嘱的张量被隐式转换为此，则为真`DType`。

------

#### `tf.DType.name`

返回此字符串的名称`DType`。

------

#### `tf.DType.base_dtype`

返回`DType`基于此的非引用`DType`。

------

#### `tf.DType.is_ref_dtype`

`True`如果它`DType`表示引用类型，则返回。

------

#### `tf.DType.as_ref`

返回`DType`基于此的引用`DType`。

------

#### `tf.DType.is_integer`

返回这是否是（非量化的）整数类型。

------

#### `tf.DType.is_quantized`

返回这是否是量化数据类型。

------

#### `tf.DType.as_numpy_dtype`

返回一个`numpy.dtype`基于此`DType`。

------

#### `tf.DType.as_datatype_enum`

返回`types_pb2.DataType`基于此的枚举值`DType`。

#### 其他方法

------

#### `tf.DType.__init__(type_enum)`

创建一个新的`DataType`。

注意（mrry）：在正常情况下，您不需要直接构造DataType对象。而是使用types.as_dtype（）函数。

##### ARGS：

- **type_enum**：`types_pb2.DataType`枚举值。

##### 举：

- **TypeError**：如果`type_enum`不是值`types_pb2.DataType`。

------

#### `tf.DType.max`

返回此数据类型中的最大可表示值。

##### 举：

- **TypeError**：如果这是非数字，无序或量化类型。

------

#### `tf.DType.min`

返回此数据类型中的最小可表示值。

##### 举：

- **TypeError**：如果这是非数字，无序或量化类型。

------

### `tf.as_dtype(type_value)`

将给定转换`type_value`为`DType`。

##### ARGS：

- **type_value**：可以转换为`tf.DType` 对象的值。这当前可能是`tf.DType`对象， [`DataType`枚举](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/types.proto)，字符串类型名称或`numpy.dtype`。

##### 返回：

一个`DType`对应的`type_value`。

##### 举：

- **TypeError**：如果`type_value`无法转换为`DType`。

## 实用功能

------

### `tf.device(dev)`

`Graph.device()`使用默认图表的包装器。

有关[`Graph.name_scope()`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Graph.name_scope) 详细信息，请参阅

##### ARGS：

- **device_name_or_function**：在上下文中使用的设备名称或函数。

##### 返回：

上下文管理器，指定用于新创建的操作的默认设备。

------

### `tf.name_scope(name)`

`Graph.name_scope()`使用默认图表的包装器。

有关[`Graph.name_scope()`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Graph.name_scope) 详细信息，请参阅

##### ARGS：

- **name**：范围的名称。

##### 返回：

`name`在默认图中作为新名称范围 安装的上下文管理器。

------

### `tf.control_dependencies(control_inputs)`

`Graph.control_dependencies()`使用默认图表的包装器。

有关[`Graph.control_dependencies()`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Graph.control_dependencies) 详细信息，请参阅

##### ARGS：

- **control_inputs**：在运行上下文中定义的操作之前必须执行或计算的一个`Operation`或多个`Tensor`对象的列表。

##### 返回：

一个上下文管理器，它指定在上下文中构造的所有操作的控制依赖性。

------

### `tf.convert_to_tensor(value, dtype=None, name=None)`

将给定转换`value`为`Tensor`。

此函数将各种类型的Python对象转换为`Tensor` 对象。它接受`Tensor`对象，numpy数组，Python列表和Python标量。例如：

```
import numpy as np
array = np.random.rand((32, 100, 100))

def my_func(arg):
  arg = tf.convert_to_tensor(arg, dtype=tf.float32)
  return tf.matmul(arg, arg) + arg

# The following calls are equivalent.
value_1 = my_func(tf.constant([[1.0, 2.0], [3.0, 4.0]]))
value_2 = my_func([[1.0, 2.0], [3.0, 4.0]])
value_3 = my_func(np.array([[1.0, 2.0], [3.0, 4.0]], dtype=np.float32))
```

在Python中编写新操作时（`my_func`例如上面的示例中），此函数非常有用。所有标准Python操作构造函数都将此函数应用于它们的每个Tensor值输入，这允许这些操作除了`Tensor`对象之外还接受numpy数组，Python列表和标量。

##### ARGS：

- **value**：类型具有已注册`Tensor`转换函数的对象。
- **dtype**：返回张量的可选元素类型。如果缺少，则从类型推断出类型`value`。
- **name**：如果`Tensor`创建了new，则使用可选名称。

##### 返回：

一个`Tensor`基于`value`。

##### 举：

- **TypeError**：如果没有注册转换功能`value`。
- **RuntimeError**：如果已注册的转换函数返回无效值。

------

### `tf.get_default_graph()`

返回当前线程的默认图形。

返回的图形将是`Graph.as_default()`输入上下文的最内层图形， 如果没有显式创建，则为全局默认图形。

*NB*默认图是当前线程的属性。如果您创建一个新线程，并希望在该线程中使用默认图形，则必须`with g.as_default():`在该线程的函数中显式添加。

##### 返回：

默认值`Graph`在当前线程中使用。

------

### `tf.import_graph_def(graph_def, input_map=None, return_elements=None, name=None, op_dict=None)`

将TensorFlow图`graph_def`导入Python `Graph`。

此函数提供了一种导入序列化TensorFlow [`GraphDef`](https://tensorflow.googlesource.com/tensorflow/+/master/tensorflow/core/framework/graph.proto) 协议缓冲区的方法，并提取`GraphDef`as[`Tensor`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Tensor)和[`Operation`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Operation)objects 中的单个对象。请参阅 [`Graph.as_graph_def()`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Graph.as_graph_def)创建 `GraphDef`原型的方法。

##### ARGS：

- **graph_def**：`GraphDef`包含要导入默认图形的操作的proto。
- **input_map**：将字符映射`graph_def` 到`Tensor`对象的输入名称（作为字符串）的字典。导入图中命名输入张量的值将重新映射到相应的`Tensor`值。
- **return_elements**：包含操作名称的字符串列表 `graph_def`将作为`Operation`对象返回; 和/或其中的张量名称`graph_def`将作为`Tensor`对象返回。
- **name**:(可选。）前缀将添加到名称中的前缀 `graph_def`。默认为`"import"`。
- **op_dict**:(可选。）将op类型名称映射到`OpDef`protos的字典。必须包含`OpDef`每个名为的op类型的proto `graph_def`。如果省略，则使用`OpDef`在全局注册表中注册的protos。

##### 返回：

导入图形 的列表`Operation`和/或`Tensor`对象，对应于`return_elements'中的名称。

##### 举：

- **TypeError**：如果`graph_def`不是`GraphDef`原型， `input_map' is not a dictionary mapping strings to`Tensor `objects, or`return_elements`不是字符串列表。
- **ValueError**：If `input_map`，或`return_elements`包含没有出现`graph_def`或者`graph_def`格式不正确的名称（例如，它指的是未知张量）。

## 图集

------

### `tf.add_to_collection(name, value)`

`Graph.add_to_collection()`使用默认图表的包装器。

有关[`Graph.add_to_collection()`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Graph.add_to_collection) 详细信息，请参阅

##### ARGS：

- **name**：收集的关键。例如，`GraphKeys`该类包含许多集合的标准名称。
- **value**：要添加到集合的值。

------

### `tf.get_collection(key, scope=None)`

`Graph.get_collection()`使用默认图表的包装器。

有关[`Graph.get_collection()`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Graph.get_collection) 详细信息，请参阅

##### ARGS：

- **key**：收集的关键。例如，`GraphKeys`该类包含许多集合的标准名称。
- **scope**:(可选。）如果提供，则过滤结果列表以仅包括名称以此字符串开头的项目。

##### 返回：

具有给定的集合中的值`name`列表，如果没有向该集合添加任何值，则为空列表。该列表包含按收集顺序排列的值。

------

### `class tf.GraphKeys`

用于图表集合的标准名称。

标准库使用各种众所周知的名称来收集和检索与图形相关联的值。例如， `tf.Optimizer`子类默认优化收集的变量，`tf.GraphKeys.TRAINABLE_VARIABLES`如果没有指定，但也可以传递显式的变量列表。

定义了以下标准键：

- `VARIABLES`：`Variable`组成模型的对象，必须一起保存和恢复。有关[`tf.all_variables()`](http://www.tensorfly.cn/tfdoc/api_docs/python/state_ops.html#all_variables) 详细信息，请参阅
- `TRAINABLE_VARIABLES`：`Variable`将由优化程序训练的对象子集。有关[`tf.trainable_variables()`](http://www.tensorfly.cn/tfdoc/api_docs/python/state_ops.html#trainable_variables) 详细信息，请参阅
- `SUMMARIES`：`Tensor`已在图形中创建的摘要对象。有关[`tf.merge_all_summaries()`](http://www.tensorfly.cn/tfdoc/api_docs/python/train.html#merge_all_summaries) 详细信息，请参阅
- `QUEUE_RUNNERS`：`QueueRunner`用于为计算生成输入的对象。有关[`tf.start_queue_runners()`](http://www.tensorfly.cn/tfdoc/api_docs/python/train.html#start_queue_runners) 详细信息，请参阅

## 定义新业务

------

### `class tf.RegisterGradient`

用于为op类型注册渐变函数的装饰器。

此装饰器仅在定义新的op类型时使用。对于具有`m`输入和`n`输入的op ，渐变函数是一个函数，它接受原始`Operation`和`n` `Tensor`对象（表示相对于op的每个输出的渐变），并返回`m` `Tensor`对象（表示相对于op的每个输入的部分渐变） ）。

例如，假设该类型的操作`"Sub"`需要两个输入`x`和`y`，并返回一个单一的输出`x - y`，使用以下梯度函数将被注册：

```
@tf.RegisterGradient("Sub")
def _sub_grad(unused_op, grad):
  return grad, tf.Neg(grad)
```

decorator参数`op_type`是操作的字符串类型。这对应于`OpDef.name`定义操作的proto 的字段。

------

#### `tf.RegisterGradient.__init__(op_type)`

使用`op_type`Operation类型创建一个新的装饰器。

##### ARGS：

- **op_type**：操作的字符串类型。这对应于`OpDef.name`定义操作的proto 的 字段。

------

### `tf.NoGradient(op_type)`

指定类型的ops `op_type`没有定义的渐变。

此功能仅在定义新的op类型时使用。它可以用于诸如`tf.size()`不可区分的操作。例如：

```
tf.NoGradient("Size")
```

##### ARGS：

- **op_type**：操作的字符串类型。这对应于`OpDef.name`定义操作的proto 的 字段。

##### 举：

- **TypeError**：如果`op_type`不是字符串。

------

### `class tf.RegisterShape`

用于为op类型注册形状函数的装饰器。

此装饰器仅在定义新的op类型时使用。形状函数是从一个函数`Operation`对象的列表 `TensorShape`的对象，一个`TensorShape`用于操作的每个输出。

例如，假设该类型的操作`"Sub"`需要两个输入`x`和`y`，并返回一个单一的输出`x - y`，都具有相同的形状，下面的形状函数将被注册：

```
@tf.RegisterShape("Sub")
def _sub_shape(op):
  return [op.inputs[0].get_shape().merge_with(op.inputs[1].get_shape())]
```

decorator参数`op_type`是操作的字符串类型。这对应于`OpDef.name`定义操作的proto 的字段。

------

#### `tf.RegisterShape.__init__(op_type)`

将“op_type”保存为“操作”类型。

------

### `class tf.TensorShape`

代表a的形状`Tensor`。

A `TensorShape`表示a的可能部分形状规范 `Tensor`。它可能是以下之一：

- *完全已知的形状：*具有已知数量的尺寸和每个尺寸的已知尺寸。
- *部分已知的形状：*具有已知数量的尺寸，并且具有一个或多个尺寸的未知尺寸。
- *未知形状：*具有未知数量的维度，并且在所有维度中具有未知大小。

如果通过类型的操作产生张量，则`"Foo"`如果存在已注册的形状函数，则可以推断其形状 `"Foo"`。有关[`tf.RegisterShape()`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#RegisterShape) 形状函数以及如何注册它们的详细信息，请参阅。或者，可以使用明确地设置形状[`Tensor.set_shape()`](http://www.tensorfly.cn/tfdoc/api_docs/python/framework.html#Tensor.set_shape)。

------

#### `tf.TensorShape.merge_with(other)`

返回`TensorShape`相结合的信息`self`和`other`。

根据为其定义的规则，元素中的维度`self`和`other`元素合并`Dimension.merge_with()`。

##### ARGS：

- **other**：另一个`TensorShape`。

##### 返回：

甲`TensorShape`含有的组合信息`self`和 `other`。

##### 举：

- **ValueError**：如果`self`和`other`不兼容。

------

#### `tf.TensorShape.concatenate(other)`

返回维度的串联`self`和`other`。

*注意*如果其中一个`self`或`other`完全未知，则连接将丢弃有关另一个形状的信息。将来，我们可能会支持将此信息保留用于切片的连接。

##### ARGS：

- **other**：另一个`TensorShape`。

##### 返回：

一个`TensorShape`其尺寸为尺寸的拼接`self`和`other`。

------

#### `tf.TensorShape.ndims`

返回此形状的等级，如果未指定，则返回None。

------

#### `tf.TensorShape.dims`

返回Dimensions列表，如果未指定形状，则返回None。

------

#### `tf.TensorShape.as_list()`

返回每个维度的整数列表或“无”。

------

#### `tf.TensorShape.is_compatible_with(other)`

返回True iff `self`与之兼容`other`。

如果存在两个形状都可以表示的完全定义的形状，则两个可能部分定义的形状是兼容的。因此，兼容性允许形状推断代码推断部分定义的形状。例如：

- TensorShape（无）与所有形状兼容。
- TensorShape（[None，None]）与所有二维形状兼容，例如TensorShape（[32,784]），以及TensorShape（无）。它与例如TensorShape（[None]）或TensorShape（[None，None，None]）不兼容。
- TensorShape（[32，None]）与第0维中尺寸为32的所有二维形状兼容，还兼容TensorShape（[None，None]）和TensorShape（无）。它与例如TensorShape（[32]），TensorShape（[32，None，1]）或TensorShape（[64，None]）不兼容。
- TensorShape（[32,784]）与它自身兼容，还有TensorShape（[32，None]），TensorShape（[None，784]），TensorShape（[None，None]）和TensorShape（None）。它与例如TensorShape（[32,1,784]）或TensorShape（[None]）不兼容。

兼容性关系是自反和对称的，但不是传递性的。例如，TensorShape（[32,784]）与TensorShape（无）兼容，TensorShape（无）与TensorShape（[4,4]）兼容，但TensorShape（[32,784]）与TensorShape不兼容（[4,4]）。

##### ARGS：

- **other**：另一个TensorShape。

##### 返回：

真的iff `self`兼容`other`。

------

#### `tf.TensorShape.is_fully_defined()`

返回True iff `self`在每个维度中完全定义。

------

#### `tf.TensorShape.with_rank(rank)`

返回基于`self`给定等级的形状。

该方法将完全未知的形状提升为具有已知等级的形状。

##### ARGS：

- **rank**：一个整数。

##### 返回：

至少`self`与给定等级一样具体的形状。

##### 举：

- **ValueError**：如果`self`不表示给定的形状`rank`。

------

#### `tf.TensorShape.with_rank_at_least(rank)`

返回基于`self`至少给定等级的形状。

##### ARGS：

- **rank**：一个整数。

##### 返回：

至少`self`与至少给定等级一样具体的形状。

##### 举：

- **ValueError**：如果`self`不代表至少给定的形状 `rank`。

------

#### `tf.TensorShape.with_rank_at_most(rank)`

返回基于`self`最多给定排名的形状。

##### ARGS：

- **rank**：一个整数。

##### 返回：

至少`self`与最多给定等级一样具体的形状。

##### 举：

- **ValueError**：如果`self`不代表最多给定的形状 `rank`。

------

#### `tf.TensorShape.assert_has_rank(rank)`

如果`self`与给定不兼容，则引发异常`rank`。

##### ARGS：

- **rank**：一个整数。

##### 举：

- **ValueError**：如果`self`不表示给定的形状`rank`。

------

#### `tf.TensorShape.assert_same_rank(other)`

如果`self`且`other`没有兼容的等级，则引发异常。

##### ARGS：

- **other**：另一个`TensorShape`。

##### 举：

- **ValueError**：如果`self`并且`other`不表示具有相同等级的形状。

------

#### `tf.TensorShape.assert_is_compatible_with(other)`

如果`self`和`other`不表示相同的形状，则引发异常。

此方法可用于断言存在既包含`self`又`other`表示的形状 。

##### ARGS：

- **other**：另一个TensorShape。

##### 举：

- **ValueError**：如果`self`并且`other`不代表相同的形状。

------

#### `tf.TensorShape.assert_is_fully_defined()`

如果`self`未在每个维度中完全定义，则引发异常。

##### 举：

- **ValueError**：如果`self`每个维度都没有已知值。

#### 其他方法

------

#### `tf.TensorShape.__init__(dims)`

创建具有给定尺寸的新TensorShape。

##### ARGS：

- **dims**：尺寸列表，如果未指定形状，则为无。
- **DEPRECATED**：单个整数被视为单例列表。

------

#### `tf.TensorShape.as_dimension_list()`

DEPRECATED：使用as_list（）。

------

#### `tf.TensorShape.num_elements()`

返回元素的总数，或者对于不完整的形状，则返回none。

------

### `class tf.Dimension`

表示TensorShape中一个维的值。

------

#### `tf.Dimension.__init__(value)`

使用给定值创建新的Dimension。

------

#### `tf.Dimension.assert_is_compatible_with(other)`

如果`other`与此Dimension不兼容，则引发异常。

##### ARGS：

- **other**：另一个维度。

##### 举：

- **ValueError**：如果`self`和`other`不兼容（请参阅is_compatible_with）。

------

#### `tf.Dimension.is_compatible_with(other)`

如果`other`与此Dimension兼容，则返回true 。

如果两个已知尺寸具有相同的值，则它们是兼容的。未知的Dimension与所有其他Dimensions兼容。

##### ARGS：

- **other**：另一个维度。

##### 返回：

如果此Dimension `other`兼容，则为True 。

------

#### `tf.Dimension.merge_with(other)`

返回一个Dimension，它结合了`self`和中的信息`other`。

尺寸组合如下：

Dimension（n）.merge_with（Dimension（n））== Dimension（n）Dimension（n）.merge_with（Dimension（None））== Dimension（n）Dimension（None）.merge_with（Dimension（n））== Dimension（n）Dimension（None）.merge_with（Dimension（None））== Dimension（None）Dimension（n）.merge_with（Dimension（m））引发n！= m的ValueError

##### ARGS：

- **other**：另一个维度。

##### 返回：

含有的组合信息维度`self`和 `other`。

##### 举：

- **ValueError**：如果`self`和`other`不兼容（请参阅is_compatible_with）。

------

#### `tf.Dimension.value`

此维度的值，如果未知，则为None。

------

### `tf.op_scope(values, name, default_name)`

返回定义Python操作时使用的上下文管理器。

此上下文管理器验证给定`values`的来自同一图形，确保该图形是默认图形，并推送名称范围。

例如，要定义一个名为的新Python操作`my_op`：

```
def my_op(a, b, c, name=None):
  with tf.op_scope([a, b, c], name, "MyOp") as scope:
    a = tf.convert_to_tensor(a, name="a")
    b = tf.convert_to_tensor(b, name="b")
    c = tf.convert_to_tensor(c, name="c")
    # Define some computation that uses `a`, `b`, and `c`.
    return foo_op(..., name=scope)
```

##### ARGS：

- **values**：`Tensor`传递给op函数的参数列表。
- **name**：传递给op函数的name参数。
- **default_name**：`name`参数为的默认名称`None`。

##### 返回：

用于定义Python操作的上下文管理器。

------

### `tf.get_seed(op_seed)`

返回操作应该使用的特定种子的本地种子。

给定特定于操作的种子，`op_seed`该辅助函数返回从图级和操作级种子派生的两个种子。许多随机操作在内部使用这两个种子来允许用户为图形全局更改种子，或仅用于特定操作。

有关图级种子如何与op种子交互的详细信息，请参阅 [`set_random_seed`](http://www.tensorfly.cn/tfdoc/api_docs/python/constant_op.html#set_random_seed)。

##### ARGS：

- **op_seed**： 整数。

##### 返回：

应该用于此操作的本地种子的两个整数的元组。